"""
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all
figurate (polygonal) numbers and are generated by the following formulae:

Triangle         P3,n = n(n+1)/2        1, 3, 6, 10, 15, ...
Square           P4,n = n*n             1, 4, 9, 16, 25, ...
Pentagonal       P5,n = n(3n-1)/2       1, 5, 12, 22, 35, ...
Hexagonal        P6,n = n(2n-1)         1, 6, 15, 28, 45, ...
Heptagonal       P7,n = n(5n-3)/2       1, 7, 18, 34, 55, ...
Octagonal        P8,n = n(3n-2)         1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

1. The set is cyclic, in that the last two digits of each number is the first two digits of
the next number (including the last number with the first).
2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal
(P5,44=2882), is represented by a different number in the set.
3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal
type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by
a different number in the set.
"""

from itertools import count, product
import sys


pent_funcs = [lambda n: n*(3*n-2),
              lambda n: int(n*(5*n-3)/2),
              lambda n: n*(2*n-1),
              lambda n: int(n*(3*n-1)/2),
              lambda n: n*n,
              lambda n: int(n*(n+1)/2)]


# Generate set of 4 digit pentagonal numbers
pent_sets = []
for i in range(6):
    l = set()
    for n in count(1):
        val = pent_funcs[i](n)
        if val > 9999:
            break
        if val > 999 and (str(val)[2:] != str(val)[:2]) and not any((val in s) for s in pent_sets):
            l.add(val)
    pent_sets.append(l)


# Cyclic if the set of starting numbers = set of ending numbers
def cyclic(num_set):
    return set([str(s)[:2] for s in num_set]) == set([str(s)[2:] for s in num_set])


# Iterate through permutations
def recurse(levels, val, sol):

    if not levels and cyclic(sol):
        print(sol, sum(sol))
        sys.exit(0)

    for idx, level in enumerate(levels):
        for n in level:
            if str(val)[:2] == str(n)[2:]:
                levels_left = levels[:]
                levels_left.pop(idx)
                recurse(levels_left, n, sol + [n])


for val in pent_sets[0]:
    recurse(pent_sets[1:], val, [val])
